<!DOCTYPE html><html><head><title>24_notes</title><meta charset="UTF-8"><style>
    body {
      margin-top: 2em;
      margin-left: 2em;
      margin-right: 2em;

      font-family: sans-serif;
    }
    code {
      color: #8B0000;
    }
    th { padding-left: 1ex; text-align: left; }
    td { padding-left: 1ex; text-align: left; }
    thead th { border-bottom: 1px solid black; }
  </style></head><body><h1>Lecture 2.4: Functional Programming — Metaprogramming</h1>
<p>We learned in lecture 2.3 how to use monads to program with implicit state and failure</p>
<p>Users can extend Lean with custom monadic tactics and tools</p>
<h2>Metaprogramming</h2>
<p><em>Metaprogramming</em>: Program the prover in its own language, using a monadic language</p>
<p>Abstract syntax trees <em>reflect</em> internal data structures, e.g. for expressions (terms)</p>
<p>The prover's C++ internals are exposed through Lean interfaces, which we can use for accessing the current context and goal, unifying expressions, querying and modifying the environment, and setting attributes (e.g. <code>@[simp]</code>)</p>
<p>Most of Lean's predefined tactics are implemented in this way (and not in C++)</p>
<h2>Example applications</h2>
<ul>
<li>
<p><strong>Proof goal transformations</strong> (e.g. apply all safe introduction rules for connectives, put the goal in negation normal form)</p>
</li>
<li>
<p><strong>Heuristic proof search</strong> (e.g. apply unsafe introduction rules for connectives and hypotheses but with backtracking)</p>
</li>
<li>
<p><strong>Decision procedures</strong> (e.g. for propositional logic, linear arithmetic)</p>
</li>
<li>
<p><strong>Definition generators</strong> (e.g. Haskell-style <code>derive</code> for inductive types)</p>
</li>
<li>
<p><strong>Advisor tools</strong> (e.g. lemma finders, counterexample generators)</p>
</li>
<li>
<p><strong>Exporters</strong> (e.g. documentation generators)</p>
</li>
<li>
<p><strong>Ad hoc automation</strong> (to avoid boilerplate or duplication)</p>
</li>
</ul>
<p>In principle, we could do everything with copy-paste, proof terms and predefined tactics, and <code>grep</code> (or Ctrl+P/Cmd+P, <code>#</code>... in Visual Studio Code), <em>but</em></p>
<h2>Advantages of metaprogramming</h2>
<ul>
<li>
<p>Users (e.g. mathematicians) do not need to learn another programming language to write metaprograms; they can work with the same constructs and notation used to define ordinary objects in the prover's library</p>
</li>
<li>
<p>Everything in that library is available for metaprogramming purposes (e.g. <code>ℤ</code>, <code>list</code>, algebraic structures)</p>
</li>
<li>
<p>Metaprograms can be written and debugged in the same interactive environment, encouraging a style where formal libraries and supporting automation are developed at the same time</p>
</li>
</ul>
<p>But see <a href="https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/">A Review of the Lean Theorem Prover</a> by Thomas Hales, especially point 4 of "What's not so great about Lean?"</p>
<h2>Metaconstants and tactics</h2>
<p>Any executable (i.e. not defined using <code>noncomputable</code>) Lean definition can be used as a metaprogram</p>
<p>In addition, we can put <code>meta</code> in front of a definition to indicate that is a <em>metadefinition</em>; these need not terminate but cannot be used in non-<code>meta</code> contexts</p>
<p>Metaprograms (whether defined with <code>meta</code> or not) can communicate with Lean through <em>metaconstants</em>, which are implemented in C++ and have no logical meaning (i.e. they are opaque names)</p>
<p>Important types:</p>
<ul>
<li>
<p><code>name</code>: hierarchical names</p>
</li>
<li>
<p><code>expr</code>: terms, types, proofs are represented as abstract syntax trees</p>
</li>
<li>
<p><code>tactic</code>: the tactic monad, which contains the proof state, the environment, etc.</p>
</li>
</ul>
<h2>Expression type</h2>
<p>Expressions may contain</p>
<ul>
<li>
<p><strong>metavariables</strong>, correponding to holes in expressions (e.g. <code>_</code>, <code>?</code> variables, subgoals)</p>
</li>
<li>
<p><strong>local constants</strong>, corresponding to the hypotheses</p>
</li>
<li>
<p><strong>bound variables</strong>, which refer variables bound by <code>λ</code> and <code>Π</code> (<code>∀</code>), using De Bruijn indices (in its <em>locally nameless</em> variant)</p>
</li>
</ul>
<p>We can create literal expressions conveniently using backticks (quotations)</p>
<h2>Tactic monad</h2>
<p>Tactics have access to</p>
<ul>
<li>
<p>the list of <strong>goals</strong> as metavariables (each metavariables has a type and a local context (hypothesis); they can optionally be instantiated)</p>
</li>
<li>
<p>the <strong>elaborator</strong> (to elaborate expressions and compute their type)</p>
</li>
<li>
<p>the <strong>attributes</strong> (e.g. the list of <code>simp</code>-rules)</p>
</li>
<li>
<p>the <strong>environment</strong>, containing all declarations and inductive types</p>
</li>
</ul>
<p>Tactics can also produce trace messages</p>
<p>The tactic monad is an <code>alternative</code> (with <code>fail</code> and <code>&lt;|&gt;</code>)</p>
<h2>Demo</h2>
<p><a href="24_lecture.lean"><code>24_lecture.lean</code></a></p>
<h2>Newly introduced syntax</h2>
<h3>Declarations</h3>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>meta</code></td>
<td>prefix for declarations in <strong>meta</strong> Lean; constant cannot be used in proofs.</td>
</tr>
<tr>
<td><code>run_cmd</code></td>
<td>executes a tactic on the top level, without a proof context</td>
</tr>
</tbody>
</table>
<h3>Notations</h3>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>`h</code></td>
<td>quotation: literal syntax for check names</td>
</tr>
<tr>
<td><code>``h</code></td>
<td>quotation: literal syntax for un-checked names</td>
</tr>
<tr>
<td><code>`(e)</code></td>
<td>quotation: fully elaborated expressions, without holes</td>
</tr>
<tr>
<td><code>``(e)</code></td>
<td>quotation: pre-expressions with checked names</td>
</tr>
<tr>
<td><code>```(e)</code></td>
<td>quotation: pre-expressions without checked names</td>
</tr>
<tr>
<td><code>%%e</code></td>
<td>antiquotation to insert a expression into a quotation</td>
</tr>
</tbody>
</table>
<h3>Metatypes</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expr</code></td>
<td>Represents expression, i.e. terms, types and proofs</td>
</tr>
<tr>
<td><code>name</code></td>
<td>Represents names, i.e. hierarchical identifiers</td>
</tr>
<tr>
<td><code>parser</code></td>
<td>Describes the syntax of interactive tactics</td>
</tr>
<tr>
<td><code>tactic</code></td>
<td>Provides the <code>tactic</code> monad and a namespace for most tactics</td>
</tr>
</tbody>
</table>
<h3>Tactic monad</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>trace</code></td>
<td>Outputs a debug string</td>
</tr>
<tr>
<td><code>get_local</code></td>
<td>Finds a local constant (i.e. expression) by name</td>
</tr>
<tr>
<td><code>local_context</code></td>
<td>Gives the list of all local constants, i.e. all assumptions in the proof</td>
</tr>
<tr>
<td><code>infer_type</code></td>
<td>Computes the type of an expression</td>
</tr>
<tr>
<td><code>to_expr</code></td>
<td>Elaborates a pre-expression</td>
</tr>
<tr>
<td><code>target</code></td>
<td>Gives the current statement to prove</td>
</tr>
<tr>
<td><code>get_goals</code></td>
<td>Gives the list of all proof holes to fill in</td>
</tr>
</tbody>
</table>
<h2>References</h2>
<ul>
<li><a href="https://leanprover.github.io/programming_in_lean/"><em>Programming in Lean</em></a>, Chapters 8 and 9</li>
</ul>
<p>Further reading:</p>
<ul>
<li><a href="https://leanprover.github.io/papers/tactic.pdf">A Metaprogramming Framework for Formal Verification</a> by Gabriel Ebner et al. (slightly outdated)</li>
</ul>
<h2>Acnkowledgment</h2>
<p>These notes are partly inspired by Gabriel Ebner et al.'s article <a href="https://leanprover.github.io/papers/tactic.pdf">A Metaprogramming Framework for Formal Verification</a></p></body></html>